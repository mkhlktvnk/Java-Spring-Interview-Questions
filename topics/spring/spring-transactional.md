# Spring @Transactional

## Как работает аннотация @Transactional в Spring?

Аннотация `@Transactional` является одной из ключевых аннотаций в Spring Framework, которая позволяет управлять
транзакциями в приложении. Когда метод или класс помечаются аннотацией `@Transactional`, Spring создает прокси-объект
для этого метода или класса, который обеспечивает декларативное управление транзакциями.

Работа аннотации `@Transactional` основана на принципах аспектно-ориентированного программирования (AOP). Spring
использует прокси-объекты для внедрения аспектов транзакций в вызываемые методы. Когда вызывается метод,
помеченный `@Transactional`, прокси-объект обрабатывает начало, фиксацию и откат транзакции в соответствии с настройками
транзакций, определенными в аннотации.

Вот основные шаги, выполняемые аннотацией `@Transactional`:

1. Создание транзакции: При вызове метода, помеченного `@Transactional`, Spring создает новую транзакцию. Транзакция
   обычно создается на уровне базы данных или другого хранилища данных.

2. Начало транзакции: Прокси-объект, созданный для метода, вызывает метод `PlatformTransactionManager` для начала
   транзакции. Это позволяет определить границы транзакции и инициировать необходимые ресурсы.

3. Выполнение метода: Метод, помеченный `@Transactional`, выполняется внутри контекста транзакции. Любые операции с
   базой данных или другими ресурсами выполняются в рамках этой транзакции.

4. Фиксация транзакции: По умолчанию, если метод завершается успешно (без выброса исключений), транзакция фиксируется.
   Это означает, что изменения, внесенные в базу данных в рамках транзакции, сохраняются.

5. Откат транзакции: Если в методе, помеченном `@Transactional`, возникает исключение, транзакция откатывается. Это
   означает, что все изменения, внесенные в базу данных в рамках транзакции, отменяются.

6. Завершение транзакции: По завершении метода, прокси-объект вызывает метод `PlatformTransactionManager` для завершения
   транзакции. Это позволяет освободить ресурсы и выполнить необходимые операции по завершению транзакции.

Аннотация `@Transactional` также предоставляет различные атрибуты для настройки транзакций, такие как уровень изоляции,
таймаут, чтение только и другие. Эти атрибуты позволяют точно настроить поведение транзакций в соответствии с
требованиями приложения.

Важно отметить, что для корректной работы аннотации `@Transactional` в Spring необходимо
настроить `PlatformTransactionManager`, который предоставляет реализацию управления транзакциями для конкретного
хранилища данных, такого как база данных. Это можно сделать путем настройки бина `PlatformTransactionManager` в
конфигурации приложения.

## Какие атрибуты можно указать в аннотации `@Transactional` и для чего они служат?

Аннотация `@Transactional` предоставляет несколько атрибутов, которые позволяют настроить поведение транзакций. Вот
некоторые из основных атрибутов:

1. `propagation`: Определяет поведение транзакции в контексте вызовов других методов. Например, можно указать, что
   транзакция должна присоединяться к текущей транзакции (`Propagation.REQUIRED`) или создавать новую
   транзакцию (`Propagation.REQUIRES_NEW`).

2. `isolation`: Определяет уровень изоляции транзакции, то есть видимость изменений, сделанных в рамках транзакции, для
   других транзакций. Некоторые значения этого атрибута
   включают `Isolation.DEFAULT`, `Isolation.READ_UNCOMMITTED`, `Isolation.READ_COMMITTED`, `Isolation.REPEATABLE_READ`
   и `Isolation.SERIALIZABLE`.

3. `readOnly`: Указывает, что транзакция должна быть только для чтения. Это позволяет оптимизировать выполнение
   операций, так как нет необходимости в фиксации изменений.

4. `timeout`: Определяет максимальное время ожидания для получения блокировки транзакции перед возникновением
   исключения `TransactionTimedOutException`.

5. `rollbackFor` и `noRollbackFor`: Позволяют указать исключения, при возникновении которых транзакция должна быть
   откачена (`rollbackFor`), или исключения, при возникновении которых транзакция не должна быть
   откачена (`noRollbackFor`).

6. `rollbackForClassName` и `noRollbackForClassName`: Похожи на предыдущие два атрибута, но принимают имена классов
   исключений в виде строк.

7. `value` или `transactionManager`: Позволяют указать имя `PlatformTransactionManager`-а, используемого для управления
   транзакциями. Если не указан, Spring попытается найти соответствующий `PlatformTransactionManager` по умолчанию.

8. `name`: Позволяет указать имя квалифицированного бина `PlatformTransactionManager`, используемого для управления
   транзакциями.

## Опишите подробно атрибут `propagation`. Какие значения можно ему установить? Приведите примеры ситуаций, где используется то или иное значение.

Атрибут `propagation` в аннотации `@Transactional` определяет поведение транзакции в контексте вызовов других методов.
Он позволяет контролировать, как текущая транзакция взаимодействует с уже существующими транзакциями или создает новую
транзакцию. Вот некоторые значения, которые можно установить для атрибута `propagation`:

1. `Propagation.REQUIRED` (по умолчанию): Если текущая транзакция уже существует, метод будет выполняться в контексте
   этой транзакции. Если транзакции нет, будет создана новая транзакция. Это наиболее распространенное значение и обычно
   используется для основных операций чтения и записи.


2. `Propagation.REQUIRES_NEW`: Всегда создает новую транзакцию. Если уже существует текущая транзакция, она будет
   приостановлена до завершения новой транзакции. Это полезно, когда методу требуется независимая транзакция, например,
   для выполнения вложенной операции или отдельного подзадачи.


3. `Propagation.MANDATORY`: Требует, чтобы уже существовала активная транзакция. Если нет активной транзакции, будет
   выброшено исключение `IllegalStateException`. Это обычно используется, когда метод зависит от родительской транзакции
   и не должен вызываться вне контекста транзакции.


4. `Propagation.SUPPORTS`: Поддерживает текущую транзакцию, если она существует. Если нет активной транзакции, метод
   будет выполняться без транзакционного контекста. Это полезно для методов, которые могут быть вызваны как с
   транзакцией, так и без нее.


5. `Propagation.NOT_SUPPORTED`: Выполняет метод без транзакционного контекста. Если существует активная транзакция, она
   будет приостановлена до выполнения метода. Это полезно для методов, которые явно не должны выполняться внутри
   транзакции.

Различные значения атрибута `propagation` в аннотации `@Transactional` могут использоваться для различных целей. Вот
несколько кейсов, где можно применять конкретные значения `propagation` с определенными целями:

1. `Propagation.REQUIRED`:
    - Цель: Обеспечить атомарность операций и сохранить их в рамках одной транзакции.
    - Кейс: Создание нового пользователя и его заказа в одном методе. Если одно из действий не выполнится успешно, все
      изменения должны быть откачены.

2. `Propagation.REQUIRES_NEW`:
    - Цель: Выполнить метод в новой независимой транзакции, не зависящей от внешнего контекста.
    - Кейс: Обработка платежа после успешного обновления информации о пользователе. Оба действия должны быть выполнены
      независимо друг от друга, и при возникновении ошибки в одном из них не должны откатываться изменения в другом.

3. `Propagation.MANDATORY`:
    - Цель: Гарантировать наличие активной транзакции, иначе выбросить исключение.
    - Кейс: Изменение информации о заказе после подтверждения платежа. Если метод вызывается без активной транзакции, он
      должен выбросить исключение, поскольку изменения должны быть выполнены только в рамках активной транзакции.

4. `Propagation.SUPPORTS`:
    - Цель: Поддержать текущую транзакцию, если она существует, и выполнить метод без транзакционного контекста, если
      транзакции нет.
    - Кейс: Получение информации о продукте, которое может быть выполнено как в контексте транзакции, так и без нее. Не
      требуется создание новой транзакции, но если текущая транзакция существует, метод может выполняться в ее рамках.

5. `Propagation.NOT_SUPPORTED`:
    - Цель: Выполнить метод без транзакционного контекста, даже если активная транзакция существует.
    - Кейс: Загрузка информации о пользователе для отображения на странице, где транзакционная поддержка не требуется.
      Если активная транзакция существует, она должна быть приостановлена, и метод должен быть выполнен без ее
      контекста.

## Опишите подробно атрибут isolation. Какие значения ему можно присвоить. Приведите кейсы, где используется то или иное значение isolation и с какой целью

Атрибут `isolation` в аннотации `@Transactional` определяет уровень изоляции транзакции, то есть степень видимости
изменений, внесенных в одну транзакцию, другим транзакциям. В Spring Framework предоставляются следующие значения для
атрибута `isolation`:

1. `Isolation.DEFAULT` (По умолчанию):
    - Цель: Использовать уровень изоляции, заданный на уровне базы данных или в конфигурации по умолчанию.
    - Кейс: Необходимо использовать уровень изоляции, предоставленный базой данных или настройками по умолчанию без
      явного задания.

2. `Isolation.READ_UNCOMMITTED`:
    - Цель: Разрешить чтение неподтвержденных изменений из других транзакций.
    - Кейс: Необходимо получить доступ к неподтвержденным данным из других транзакций, допуская возможность чтения "
      грязных" данных.

3. `Isolation.READ_COMMITTED`:
    - Цель: Разрешить чтение только подтвержденных изменений из других транзакций.
    - Кейс: Желательно избежать чтения неподтвержденных данных, но при этом можно допустить чтение изменений, которые
      уже были подтверждены другими транзакциями.

4. `Isolation.REPEATABLE_READ`:
    - Цель: Гарантировать повторяемое чтение данных, то есть отсутствие фантомных строк.
    - Кейс: Необходимо обеспечить, чтобы повторные чтения данных внутри транзакции не приводили к появлению новых строк
      или исчезновению существующих строк.

5. `Isolation.SERIALIZABLE`:
    - Цель: Обеспечить сериализуемость транзакций, то есть выполнение их последовательно и избежание конфликтов.
    - Кейс: Когда требуется строгая изоляция и невозможность одновременного изменения данных, например, при выполнении
      сложных операций или манипуляциях с высокой степенью конкуренции.

## Какие типы исключений обрабатывает аннотация `@Transactional` по умолчанию?

Аннотация `@Transactional` в Spring Framework по умолчанию обрабатывает следующие типы исключений:

1. `RuntimeException` и его подклассы:
    -
    Примеры: `NullPointerException`, `IllegalArgumentException`, `DataAccessException`, `OptimisticLockingFailureException`
    и другие исключения времени выполнения.
    - Поведение: Если метод помечен как `@Transactional` и выбрасывает исключение `RuntimeException` или его подкласс,
      то транзакция будет откатываться.

2. `Error` и его подклассы:
    - Примеры: `OutOfMemoryError`, `StackOverflowError` и другие критические ошибки.
    - Поведение: Если метод выбрасывает исключение типа `Error` или его подкласс, то транзакция не будет откатываться,
      поскольку ошибка считается неустранимой.

3. `Exception` и его подклассы, за исключением исключений времени выполнения:
    - Примеры: `IOException`, `SQLException`, `ClassNotFoundException` и другие исключения, не являющиеся исключениями
      времени выполнения.
    - Поведение: Если метод выбрасывает исключение типа `Exception` или его подкласс, то транзакция будет откатываться.

Обработка исключений в аннотации `@Transactional` позволяет определить поведение транзакции в случае возникновения
исключения.
При выбрасывании исключения, соответствующего одному из вышеуказанных типов, транзакция может быть откачена (откат) или
завершена успешно (фиксация) в зависимости от конфигурации транзакционного менеджера и обработчика исключений.

## Как можно настроить поведение транзакции при определенных исключениях с помощью аннотации `@Transactional`?

Для настройки поведения транзакции при определенных исключениях с помощью аннотации `@Transactional` вы можете
использовать параметр `rollbackFor`. Этот параметр позволяет указать исключения, при возникновении которых транзакция
должна быть откатана (rollback).

Пример использования аннотации `@Transactional` с параметром `rollbackFor`:

```java
@Transactional(rollbackFor = {CustomException.class, AnotherException.class})
public void performTransaction() {
    // Код метода
}
```

В приведенном примере транзакция будет автоматически откатана (rollback), если возникнет исключение
типа `CustomException` или `AnotherException`.

Если вам необходимо убрать определенные исключения из автоматического отката транзакции, вы можете использовать
параметр `noRollbackFor`:

```java
@Transactional(noRollbackFor = {SpecificException.class})
public void performTransaction() {
    // Код метода
}
```

В этом случае транзакция не будет откатана, если возникнет исключение типа `SpecificException`.

Вы также можете использовать параметры `rollbackFor` и `noRollbackFor` одновременно для более гибкого управления
поведением транзакции:

```java
@Transactional(rollbackFor = {CustomException.class}, noRollbackFor = {SpecificException.class})
public void performTransaction() {
    // Код метода
}
```

В этом примере транзакция будет откатана только при возникновении исключения типа `CustomException`, но не будет
откатана, если возникнет исключение типа `SpecificException`.

## Можно ли применить аннотацию `@Transactional` к классу вместо метода? Как это повлияет на поведение транзакции?

Да, аннотацию `@Transactional` можно применять как к методам, так и к классам в языке программирования Java. Применение
аннотации `@Transactional` к классу означает, что все методы в этом классе, которые являются транзакционными (то есть
помечены аннотацией `@Transactional` или удовлетворяют другим правилам транзакций), будут выполняться в рамках одной
транзакции.

Когда аннотация `@Transactional` применяется к классу, она определяет поведение транзакций для всех методов в этом
классе. Это означает, что все транзакционные методы будут выполняться в одной транзакции базы данных.

Пример применения аннотации `@Transactional` к классу:

```java
@Transactional
public class TransactionalClass {
    public void method1() {
        // Код метода 1
    }
    
    public void method2() {
        // Код метода 2
    }
}
```

В данном примере оба метода `method1` и `method2` будут выполняться в рамках одной транзакции. Если один из методов
выбросит исключение, вся транзакция будет откатана (rollback), и все изменения, сделанные в рамках транзакции, будут
отменены.

Применение аннотации `@Transactional` к классу может быть полезным, если вы хотите обеспечить единообразное поведение
транзакций для всех методов в классе. Однако стоит помнить, что если внутри класса есть методы, которым требуется
отдельное поведение транзакции, вы можете пометить эти методы аннотацией `@Transactional` с более конкретной
конфигурацией, переопределяющей настройки, определенные на уровне класса.

Таким образом, применение аннотации `@Transactional` к классу влияет на поведение транзакций, обеспечивая выполнение
всех транзакционных методов в рамках одной транзакции.

## Каков порядок применения аннотации `@Transactional` в иерархии классов и интерфейсов?

Порядок применения аннотации `@Transactional` в иерархии классов и интерфейсов определяется правилами наследования в
Java. Вот некоторые особенности, которые следует учитывать:

1. Если аннотация `@Transactional` применяется к методу в классе, она имеет более высокий приоритет, чем
   аннотация `@Transactional`, примененная к интерфейсу, который этот класс реализует. То есть настройки, определенные в
   аннотации `@Transactional` метода класса, будут иметь приоритет перед настройками, определенными в
   аннотации `@Transactional` интерфейса.

2. Если класс реализует несколько интерфейсов, каждый из которых имеет свою аннотацию `@Transactional`, то настройки
   транзакции будут наследоваться от всех интерфейсов. При этом, если аннотации на интерфейсах определены с разными
   параметрами, может возникнуть конфликт. В таком случае вам следует явно указать желаемые настройки транзакции на
   уровне класса или метода.

3. Если аннотация `@Transactional` применена к интерфейсу, который расширяется другим интерфейсом, наследование
   аннотации также применяется. Это означает, что классы, реализующие расширенный интерфейс, также наследуют
   аннотацию `@Transactional`.

Пример:

```java
public interface TransactionalInterface {
    @Transactional
    void transactionalMethod();
}

public interface ExtendedInterface extends TransactionalInterface {
    void anotherMethod();
}

public class TransactionalClass implements ExtendedInterface {
    public void transactionalMethod() {
        // Код метода
    }
    
    public void anotherMethod() {
        // Код метода
    }
}
```

В приведенном примере метод `transactionalMethod()` наследуется от `TransactionalInterface` и будет выполняться в рамках
транзакции, так как он помечен аннотацией `@Transactional`. Метод `anotherMethod()` не является транзакционным, так как
в его объявлении не указана аннотация `@Transactional`.

Учитывайте эти особенности при применении аннотации `@Transactional` в иерархии классов и интерфейсов, чтобы достичь
нужного поведения транзакций.

## Как работает прокси-объект, создаваемый для класса, помеченного аннотацией `@Transactional`?

В контексте аннотации `@Transactional` в Java, прокси-объект создается для класса, помеченного этой аннотацией, с
помощью механизма проксирования, предоставляемого фреймворком, таким как Spring. Прокси-объект представляет собой
обертку над реальным объектом и предоставляет дополнительную функциональность для управления транзакциями.

Когда объект класса, помеченного аннотацией `@Transactional`, создается, фреймворк создает прокси-объект, который
наследуется от этого класса и реализует те же самые интерфейсы (если применимо). Прокси-объект перехватывает вызовы
методов и внедряет логику управления транзакциями до и после выполнения методов.

Прокси-объект может выполнять следующие задачи:

1. Открытие транзакции: Перед выполнением метода прокси-объект открывает новую транзакцию базы данных или присоединяется
   к существующей.

2. Управление транзакцией: Прокси-объект следит за ходом выполнения метода и контролирует транзакцию. Если метод успешно
   выполняется, транзакция будет зафиксирована (commit). В случае возникновения исключения, транзакция будет откатана (
   rollback), и все изменения будут отменены.

3. Закрытие транзакции: После выполнения метода прокси-объект закрывает транзакцию. Здесь могут выполняться
   дополнительные операции, такие как очистка ресурсов или финализация.

Прокси-объект обеспечивает прозрачность для клиента, который вызывает методы класса. Клиент может работать с объектом
класса, как если бы это был обычный объект, не зная о наличии прокси-объекта и управлении транзакциями.

Прокси-объекты обычно создаются с помощью динамического проксирования или с использованием аспектно-ориентированного
программирования (AOP). Это позволяет фреймворку внедрять логику транзакций в объекты без необходимости изменения кода
самого класса.

Таким образом, прокси-объект, созданный для класса, помеченного аннотацией `@Transactional`, обеспечивает управление
транзакциями, добавляя логику открытия, управления и закрытия транзакций вокруг методов класса. Это позволяет упростить
и централизовать управление транзакциями в приложении.