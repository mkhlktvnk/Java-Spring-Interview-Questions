# JUnit 

## Что такое аннотация @Test в JUnit, и для чего она используется?
Аннотация `@Test` в JUnit 5 используется для пометки метода как тестового. Она указывает, что данный метод должен быть выполнен как тест и будет проверять определенное поведение или функциональность программного кода. Аннотация `@Test` позволяет JUnit определить, какие методы следует запустить во время тестирования, и какие результаты ожидать.

## Какие методы жизненного цикла (`lifecycle methods`) есть в JUnit, и какова их последовательность выполнения при запуске тестов?
1. `@BeforeEach`: Метод, помеченный аннотацией `@BeforeEach`, выполняется перед каждым тестовым методом. Он используется для инициализации общих ресурсов, настройки перед каждым тестом.

2. `@BeforeAll`: Метод, помеченный аннотацией `@BeforeAll`, выполняется единожды перед запуском всех тестов в классе. Он используется для настройки и инициализации статических ресурсов, которые должны быть доступны для всех тестов.

3. `@Test`: Сам тестовый метод, помеченный аннотацией `@Test`, выполняется для проверки определенного поведения или функциональности.

4. `@AfterEach`: Метод, помеченный аннотацией `@AfterEach`, выполняется после каждого тестового метода. Он используется для освобождения ресурсов или очистки после каждого теста.

5. `@AfterAll`: Метод, помеченный аннотацией `@AfterAll`, выполняется единожды после выполнения всех тестов в классе. Он используется для завершения работы с общими ресурсами или освобождения статических ресурсов.

Последовательность выполнения методов жизненного цикла при запуске тестов: `@BeforeAll` (единожды) -> `@BeforeEach` (перед каждым тестом) -> `@Test` (тестовый метод) -> `@AfterEach` (после каждого теста) -> `@AfterAll` (единожды).

## Что такое `assertion` в JUnit, и какие методы ассертов предоставляются для проверки условий в тестах?

`Assertion` в JUnit 5 представляет собой проверки условий и ожидаемых результатов в тестах. JUnit 5 предоставляет широкий набор методов ассертов для проверки различных условий. Вот полный список методов ассертов в JUnit 5:

- `assertEquals(expected, actual)`: Проверяет, что ожидаемое значение (`expected`) равно фактическому значению (`actual`).
- `assertNotEquals(unexpected, actual)`: Проверяет, что ожидаемое значение (`unexpected`) не равно фактическому значению (`actual`).
- `assertTrue(condition)`: Проверяет, что условие (`condition`) истинно.
- `assertFalse(condition)`: Проверяет, что условие (`condition`) ложно.
- `assertNull(object)`: Проверяет, что объект (`object`) является `null`.
- `assertNotNull(object)`: Проверяет, что объект (`object`) не является `null`.
- `assertSame(expected, actual)`: Проверяет, что ожидаемый объект (`expected`) и фактический объект (`actual`) являются одним и тем же объектом.
- `assertNotSame(unexpected, actual)`: Проверяет, что фактический объект (`actual`) не является тем же объектом, что и неожиданный объект (`unexpected`).
- `assertArrayEquals(expectedArray, actualArray)`: Проверяет, что ожидаемый массив (`expectedArray`) равен фактическому массиву (`actualArray`).
- `assertIterableEquals(expectedIterable, actualIterable)`: Проверяет, что ожидаемая итерируемая коллекция (`expectedIterable`) равна фактической итерируемой коллекции (`actualIterable`).
- `assertThrows(expectedType, executable)`: Проверяет, что выполнение кода (`executable`) выбрасывает исключение определенного типа (`expectedType`).

## Как в JUnit можно тестировать исключения (`exceptions`) и утверждать, что они должны быть сгенерированы?

В JUnit есть метод `assertThrows`, который используется для тестирования исключений и проверки того, что определенное исключение должно быть сгенерировано. Вот полный список методов `assertThrows`:

1. `assertThrows(ExpectedExceptionType.class, Executable)`: Проверяет, что выполнение кода (`Executable`) выбрасывает исключение определенного типа (`ExpectedExceptionType`).

2. `assertThrows(ExpectedExceptionType.class, Lambda)`: Проверяет, что выполнение лямбда-выражения (`Lambda`) выбрасывает исключение определенного типа (`ExpectedExceptionType`).

3. `assertThrows(ExpectedExceptionType.class, Supplier)`: Проверяет, что выполнение функции-поставщика (`Supplier`) выбрасывает исключение определенного типа (`ExpectedExceptionType`).

## Что такое параметры тестового метода в JUnit 5, и как их можно передать?

Аннотация `@ParameterizedTest` в JUnit 5 позволяет передавать параметры в тестовый метод. Она используется вместе с другими аннотациями, такими как:

- `@ValueSource`: позволяет передавать простые значения, такие как строки, числа, булевы значения и другие, в тестовый метод.

- `@EnumSource`: позволяет передавать значения из перечислений в тестовый метод.

- `@CsvSource`: позволяет передавать значения из CSV-строки в тестовый метод.

- `@MethodSource`: позволяет передавать параметры из статического метода в тестовый метод.

- `@ArgumentsSource`: позволяет передавать параметры из собственного источника, реализованного пользователем, в тестовый метод.

## Каким образом можно организовать группировку тестов и выполнение только определенных групп в JUnit?

В JUnit 5 для организации группировки тестов и выполнения только определенных групп можно использовать тегирование (`tagging`). Для этого можно использовать аннотацию `@Tag` для тегирования тестовых методов или классов.

Чтобы выполнить определенную группу тестов, можно использовать фильтрацию по тегам при запуске тестов. Для этого можно использовать аргументы командной строки, системные свойства или аннотацию `@IncludeTags` в сочетании с запуском тестового движка, например, `@RunWith` или `@ExtendWith`.

## Для чего нужны аннотации `@RunWtih` и `@ExtendWith`?

Аннотация `@RunWith` в JUnit 4 и аннотация `@ExtendWith` в JUnit 5 используются для расширения функциональности фреймворка тестирования. Они позволяют подключать сторонние расширения (extensions) или использовать альтернативные тестовые движки (test engines) для запуска тестов.

## Как можно запустить тесты параллельно (`parallel execution`) в JUnit?

В JUnit 5 можно запустить тесты параллельно, используя аннотацию `@Execution(ExecutionMode.CONCURRENT)` на уровне класса или метода. Это позволяет выполнять тесты в нескольких потоках одновременно, ускоряя общее время выполнения тестов.

Кроме того, в JUnit 5 можно настроить количество потоков для параллельного выполнения с помощью системного свойства или аргумента командной строки `junit.jupiter.execution.parallel.config.strategy`. Значениями могут быть `fixed` (фиксированное количество потоков), `dynamic` (динамическое количество потоков, основывающееся на доступных ядрах процессора) или `custom` (пользовательская стратегия).

## Что такое `test suite` в JUnit, и как можно создать и запустить набор тестов?
`Test suite` в JUnit представляет собой группу тестов, которые могут быть запущены вместе. Он позволяет организовать и запустить несколько тестовых классов или методов в одном месте.

В JUnit 4 для создания и запуска тестового набора можно использовать класс `TestSuite`. Необходимо создать экземпляр `TestSuite`, добавить в него тестовые классы или методы с помощью метода `addTest()` или `addTestSuite()`, а затем запустить тестовый набор с помощью метода `runTest()` или `run()`.

В JUnit 5 поддержка `test suite` является устаревшей. Вместо этого рекомендуется использовать аннотацию `@Nested` для вложенных классов тестов и запускать тесты с помощью средств сборки (например, Maven или Gradle) или среды разработки (например, IntelliJ IDEA или Eclipse).

## Что такое `@Ignore` аннотация в JUnit, и как она используется?

`@Ignore` - это аннотация в JUnit, которая используется для временного отключения выполнения определенных тестов или тестовых методов. Когда аннотация `@Ignore` применяется к тесту или тестовому методу, JUnit игнорирует его при запуске тестового набора.

## Как можно управлять порядком выполнения тестов в JUnit?

1. Используйте аннотацию `@Order` в JUnit 5: С помощью этой аннотации можно указать порядковый номер для каждого тестового метода или тестового класса. Тесты будут выполняться в порядке возрастания указанных номеров.

2. Используйте `@FixMethodOrder` в JUnit 4: Аннотация `@FixMethodOrder` позволяет задать порядок выполнения тестовых методов в классе. Вы можете указать одну из стратегий: `MethodSorters.DEFAULT`, `MethodSorters.NAME_ASCENDING` или `MethodSorters.JVM`.



