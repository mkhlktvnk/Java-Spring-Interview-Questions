# Mockito

## Что такое Mockito и для чего он используется?

Mockito - это фреймворк для создания мок-объектов в Java, используемый для тестирования. Он помогает создавать заглушки
для зависимостей и задавать ожидаемое поведение, что упрощает изоляцию кода и создание надежных тестов.

## Как создать мок-объект с помощью Mockito?

Для создания мок-объекта с помощью Mockito можно использовать статический метод `mock()` класса Mockito и передать класс
или интерфейс в качестве аргумента. Например: `MyClass myMock = Mockito.mock(MyClass.class);`. Этот метод создаст
мок-объект, соответствующий указанному классу или интерфейсу, который можно использовать для настройки ожидаемого
поведения и проверки вызовов методов.
Также, можно использовать аннотацию `@Mock`, но для этого нужно добавить аннотацию `@RunWith(MockitoJUnitRunner.class)`
для JUnit4 или `@ExtendWith` для JUnit 5.

## Каким образом можно задать поведение мок-объекта с помощью Mockito?

Поведение мок-объекта в Mockito можно задать с помощью метода `when()` и вызова соответствующего метода для задания
возвращаемого значения или выброса исключения:

```java
Mockito.when(myMock.someMethod()).thenReturn("результат");
```

## Как проверить вызов метода на мок-объекте с определенными аргументами?

Для проверки вызова метода на мок-объекте с определенными аргументами в Mockito используется метод `verify()`, в который
передаются мок-объект и ожидаемый вызов метода с соответствующими аргументами.

Пример кода:

```java
// Создание мок-объекта
MyClass myMock=Mockito.mock(MyClass.class);

// Вызов метода на мок-объекте
        myMock.someMethod("аргумент");

// Проверка вызова метода с определенными аргументами
        Mockito.verify(myMock).someMethod("аргумент");
```

## Каким образом можно проверить количество вызовов метода на мок-объекте с помощью Mockito?

Для проверки количества вызовов метода на мок-объекте с помощью Mockito используется метод `verify()` с передачей
ожидаемого количества вызовов вторым аргументом.

Пример кода:

```java
// Создание мок-объекта
MyClass myMock=Mockito.mock(MyClass.class);

// Вызов метода на мок-объекте
        myMock.someMethod();
        myMock.someMethod();

// Проверка количества вызовов метода
        Mockito.verify(myMock,Mockito.times(2)).someMethod();
```

## Можно ли использовать Mockito для мокирования статических методов или конструкторов?

Нет, Mockito не поддерживает мокирование статических методов или конструкторов.

## Каким образом можно проверить, что на мок-объекте был выполнен определенный метод, но без проверки аргументов?

Метод `verify()` с аргументом `Mockito.any()`: `Mockito.verify(myMock).someMethod(Mockito.any());`

Пример кода:

```java
// Создание мок-объекта
MyClass myMock=Mockito.mock(MyClass.class);

// Вызов метода на мок-объекте
        myMock.someMethod("аргумент");

// Проверка выполнения метода без проверки конкретных аргументов
        Mockito.verify(myMock).someMethod(Mockito.any());
```

## Каким образом можно задать исключение, которое будет выброшено при вызове метода на мок-объекте?

Есть несколько способов задать исключение, которое будет выброшено при вызове метода на мок-объекте:

1. Метод `thenThrow()`: `Mockito.when(myMock.someMethod()).thenThrow(Exception.class);`
2. Метод `doThrow()`: `Mockito.doThrow(Exception.class).when(myMock).someMethod();`

## Каким образом можно мокировать методы, которые возвращают void?

Для мокирования методов, которые возвращают `void`, в Mockito используется метод `doNothing()`.

Пример кода:

```java
// Создание мок-объекта
MyClass myMock=Mockito.mock(MyClass.class);

// Мокирование метода, возвращающего void
        Mockito.doNothing().when(myMock).someMethod();

// Вызов метода на мок-объекте
        myMock.someMethod();

// Проверка вызова метода
        Mockito.verify(myMock).someMethod();
```



