# Многопоточность и параллелизм

# 1. Теория по многопоточности и параллелизму

## Что такое многопоточность?

Многопоточность - это возможность программы выполнять несколько потоков (независимых последовательностей исполнения)
одновременно.
Каждый поток может выполнять свои задачи параллельно с другими потоками, что позволяет увеличить эффективность
использования ресурсов и улучшить отзывчивость программы.

## Что такое параллелизм?

Параллелизм - это концепция, при которой задачи разделяются на множество независимых подзадач и могут быть выполнены
одновременно и параллельно на нескольких вычислительных ресурсах.
В контексте многопоточности и вычислительных систем, параллелизм позволяет выполнять операции одновременно для
увеличения общей производительности и сокращения времени выполнения задач.

## Чем параллелизм отличается от многопоточности?

Параллелизм и многопоточность - это два связанных, но различных понятия.

Многопоточность относится к концепции, при которой программное обеспечение может выполнять несколько потоков (
независимых последовательностей исполнения) в пределах одного процесса.
Потоки могут выполняться параллельно или последовательно на вычислительных ресурсах, таких как процессорные ядра.

Параллелизм, с другой стороны, относится к концепции, при которой задачи выполняются одновременно в разных
вычислительных ресурсах, таких как множество процессорных ядер или даже разные компьютеры в распределенной среде.
Параллелизм может быть достигнут с использованием многопоточности, но он также может быть реализован с помощью
распределенных вычислений или использования специализированных параллельных процессоров.

Таким образом, многопоточность относится к выполнению нескольких потоков в пределах одного процесса, а параллелизм
относится к выполнению задач одновременно в разных вычислительных ресурсах.
Многопоточность является одним из способов достижения параллелизма, но они не являются взаимозаменяемыми понятиями.

## Какие существуют виды параллелизма в многопоточных системах и в чем их отличия?

1. **Параллелизм на уровне задач (Task-Level Parallelism)**: Этот вид параллелизма предполагает выполнение различных
   задач или операций независимо друг от друга. Задачи могут быть выполнены параллельно, без необходимости обмена
   данными или синхронизации между ними. Примеры такого параллелизма включают выполнение независимых вычислений,
   обработку независимых запросов или выполнение параллельных алгоритмов.
2. **Параллелизм на уровне данных (Data-Level Parallelism)**: В этом виде параллелизма данные разделяются между
   несколькими потоками или процессами, и каждый поток работает с отдельными порциями данных. Каждый поток выполняет
   одинаковые операции над своей частью данных, что позволяет достичь ускорения выполнения. Примеры такого параллелизма
   включают параллельную обработку массивов данных, параллельную обработку пикселей изображения или параллельную
   обработку элементов коллекции.

## Опишите, как устроены потоки на низком уровне

1. **Регистры потоков**:
    - Каждый поток имеет свой набор регистров, включая регистры общего назначения, указатель команд (Instruction
      Pointer) и стековый указатель.
    - Регистры хранят состояние потока, включая значения переменных, указатель на текущую выполняемую инструкцию и
      состояние стека.

2. **Планирование потоков**:
    - Операционная система отвечает за планирование и переключение потоков на процессоре.
    - Планировщик выбирает, какой поток будет выполняться на процессоре в определенный момент времени.
    - Переключение между потоками происходит в особых точках, называемых контекстными переключениями.

3. **Контекстные переключения**:
    - Контекстное переключение происходит, когда операционная система сохраняет состояние текущего потока и загружает
      состояние следующего потока для выполнения.
    - Это включает сохранение значений регистров, указателя команд, стека и других данных, специфичных для потока.
    - Контекстные переключения требуют времени и ресурсов, поэтому оптимизация и уменьшение их количества важны для
      повышения производительности.

4. **Синхронизация потоков**:
    - Для обеспечения безопасности и согласованности данных при работе с несколькими потоками используются примитивы
      синхронизации, такие как мьютексы, семафоры и условные переменные.
    - Эти примитивы позволяют ограничить доступ к общим ресурсам и обеспечить правильное взаимодействие между потоками.

5. **Параллелизм и распределение потоков**:
    - На многоядерных процессорах потоки могут выполняться параллельно на разных ядрах.
    - Операционная система может распределять потоки по разным ядрам для более эффективного использования вычислительных
      ресурсов.

## Чем поток отличается от процесса?

- Основное отличие между процессами и потоками заключается в том, что процесс является изолированной программой с
  собственной областью памяти, в то время как потоки существуют внутри процесса и разделяют его ресурсы.
- Процессы требуют больше системных ресурсов, так как каждый процесс имеет свою собственную область памяти и ресурсы
  операционной системы, в то время как потоки более легковесны и используют общие ресурсы процесса.
- Потоки могут быть более эффективными в выполнении параллельных задач и обеспечении многопоточности, так как они
  используют общую память и могут быстрее обмениваться данными.

В итоге процесс представляет собой программу, выполняющуюся в операционной системе, а поток является исполняющейся
последовательностью инструкций внутри процесса, которая может выполняться параллельно с другими потоками.

## Объясните понятие потокобезопасности (thread-safety) и почему это важно при разработке многопоточных приложений. Какие подходы можно использовать для достижения потокобезопасности?

Потокобезопасность (thread-safety) в контексте многопоточных приложений означает, что код или структуры данных могут
быть безопасно использованы из нескольких потоков одновременно без возникновения нежелательных побочных эффектов или
гонок данных.
Это важно, поскольку многопоточные приложения имеют несколько параллельно выполняющихся потоков, которые могут
одновременно обращаться к общим ресурсам, таким как переменные, объекты или файлы.
Если код или данные не являются потокобезопасными, могут возникнуть состояния гонки, неправильные результаты или даже
ошибки выполнения программы.

Для достижения потокобезопасности можно использовать следующие подходы:

1. Синхронизация: Использование механизмов синхронизации, таких как мьютексы, семафоры или блокировки, чтобы
   гарантировать, что только один поток имеет доступ к критическим секциям кода или данным в определенный момент
   времени.
2. Использование неизменяемости (Immutability): Создание неизменяемых объектов или объектов, которые не могут быть
   модифицированы после создания. Это устраняет необходимость синхронизации, поскольку неизменяемые объекты могут быть
   безопасно использованы в многопоточной среде.
3. Использование потокобезопасных коллекций: В Java, например, существуют специальные классы коллекций, такие
   как `ConcurrentHashMap` или `CopyOnWriteArrayList`, которые обеспечивают потокобезопасное использование данных без
   явной синхронизации.
4. Атомарные операции: Использование атомарных операций, которые гарантируют, что операции над переменными будут
   выполняться атомарно, без вмешательства других потоков.
5. Thread-local переменные: Использование переменных, которые имеют отдельные экземпляры для каждого потока, чтобы
   избежать состояний гонки при доступе к переменным из разных потоков.

## Какие проблемы могут возникать при работе с общими данными в многопоточной среде?

1. **Гонки данных (Data Races)**: Несколько потоков могут одновременно читать и записывать общие данные, что может
   привести к непредсказуемым результатам. Гонки данных могут привести к состояниям гонки (race conditions), при которых
   результаты операций зависят от того, какие потоки выполняются в каком порядке.

2. **Взаимная блокировка (Deadlock)**: Это ситуация, когда два или более потоков ожидают ресурс, который удерживается
   другим потоком. Каждый поток блокирует ресурс, необходимый другому потоку для продолжения работы, и из-за этого
   происходит замедление или зависание программы.

3. **Проблемы видимости (Visibility Issues)**: Изменения, внесенные одним потоком в общие данные, могут не быть видимыми
   другим потокам. Это может привести к неправильному чтению данных или некорректной синхронизации.

4. **Избыточная синхронизация (Over-Synchronization)**: Неправильное использование механизмов синхронизации, таких как
   блокировки или мьютексы, может привести к избыточной синхронизации. Это может ухудшить производительность программы и
   создать возможность для взаимной блокировки.

5. **Управление ресурсами**: В многопоточной среде управление ресурсами, такими как память или файловые дескрипторы,
   становится более сложным. Неправильное использование или неосмотрительное освобождение ресурсов может привести к
   утечкам памяти или другим проблемам.

## Что такое deadlock?

Deadlock (взаимная блокировка) - это состояние в многопоточной или распределенной системе, когда два или более потока (
или процесса) блокируются и ожидают ресурс, который занят другими потоками, которые также ожидают другие ресурсы.
В результате ни один из потоков не может продолжить свою работу, и система оказывается в застойном состоянии.

Причинами возникновения deadlock могут быть:

1. Взаимная блокировка ресурсов: Каждый поток удерживает один ресурс и ожидает освобождения другого ресурса, занятого
   другим потоком.
2. Взаимное ожидание: Каждый поток ожидает ресурс, занятый другим потоком, в то время как удерживает свой ресурс.
3. Отсутствие прерывания: Потоки не могут быть прерваны или освободить ресурсы до тех пор, пока не выполнится
   определенное условие.

## Что такое livelock и чем он отличается от deadlock?

Livelock (живая блокировка) - это состояние взаимодействия нескольких потоков, когда они находятся в постоянном
состоянии активности, но не могут продвинуться вперед или завершить свою работу из-за действий других потоков.
В результате потоки не блокируются, как в deadlock, но зацикливаются в активных операциях без реального прогресса.

Отличия между livelock и deadlock:

- В deadlock потоки находятся в блокировке, ожидая ресурсы, которые удерживают другие потоки. В livelock потоки активны,
  но не могут сделать прогресс из-за конфликтующих действий других потоков.
- В deadlock потоки ожидают друг друга, создавая циклическую зависимость. В livelock потоки постоянно реагируют на
  действия других потоков, что приводит к взаимной блокировке.
- Deadlock является более серьезной проблемой, так как потоки полностью заблокированы и не могут продолжить работу.
  Livelock, хотя и создает неэффективное состояние, но потоки все еще активны и пытаются выполнять операции.

## Что такое позитивная и пессимистическая блокировка?

Позитивная и пессимистическая блокировка - это два подхода к управлению доступом к общим ресурсам в многопоточной среде.

1. Позитивная блокировка (Optimistic Locking): При позитивной блокировке поток считывает состояние ресурса без
   блокировки и выполняет операции над данными. После завершения операций поток проверяет, были ли изменения в состоянии
   ресурса другими потоками. Если изменений не произошло, поток продолжает свою работу. В противном случае, если
   обнаружены конфликты, поток может повторить операции с обновленным состоянием ресурса. Позитивная блокировка
   основывается на предположении, что конфликты будут редкими, и большая часть операций будет выполняться без
   блокировки, что способствует повышению производительности.

2. Пессимистическая блокировка (Pessimistic Locking): При пессимистической блокировке поток блокирует ресурс, прежде чем
   выполнять операции над ним. Другие потоки, пытающиеся получить доступ к заблокированному ресурсу, будут ожидать, пока
   блокировка не будет снята. Пессимистическая блокировка используется в ситуациях, когда ожидается, что конфликты будут
   частыми, и блокировка необходима для обеспечения корректности выполнения операций. Это может привести к снижению
   производительности из-за возможных блокировок и ожиданий.

## Что такое синхронизация и для чего она нужна?

Синхронизация - это механизм, используемый в многопоточной среде для обеспечения правильного доступа к общим данным и
предотвращения проблем, связанных с гонками данных и неправильным порядком выполнения операций.
Механизмы синхронизации, такие как блокировки, мьютексы и условные переменные, обеспечивают контроль над доступом к
общим данным и обеспечивают правильный порядок выполнения операций в многопоточной среде.
Однако неправильное использование синхронизации может привести к проблемам, таким как взаимная блокировка или избыточная
синхронизация, поэтому важно использовать синхронизацию аккуратно и с учетом особенностей конкретной задачи.

## Что такое критическая секция?

Критическая секция - это участок кода в многопоточной программе, где доступ и изменение общих данных должны быть
синхронизированы между потоками.
Это означает, что только один поток может одновременно выполнять код в критической секции, чтобы избежать
непредсказуемого и некорректного состояния общих данных.
Критические секции используются для предотвращения гонок данных и конфликтов доступа к общим ресурсам.

## Какие существуют подходы управления доступом к критической секции?

1. **Неограниченный доступ**: Каждый поток может получить доступ к критической секции в любое время без каких-либо
   ограничений. Это называется несправедливым (unfair) доступом.
2. **Справедливый доступ**: Потоки получают доступ к критической секции в порядке их запросов. Если несколько потоков
   ожидают доступа к критической секции, то они будут получать доступ в порядке очереди. Это называется справедливым (
   fair) доступом.
3. **Приоритетный доступ**: Потокам назначается приоритет, и поток с более высоким приоритетом получает доступ к
   критической секции в первую очередь. Приоритет может быть определен статически или динамически, в зависимости от
   требований приложения.
4. **Ограниченный доступ**: Устанавливается максимальное количество потоков, которым разрешен доступ к критической
   секции одновременно. Если количество потоков превышает это значение, остальные потоки должны ожидать освобождения
   ресурса.
5. **Блокировка с таймаутом**: Потоки ждут доступа к критической секции в течение определенного времени. Если доступ не
   удается получить в течение указанного времени, поток может прекратить ожидание и продолжить выполнение других
   операций.

## Какие примитивы синхронизации вы знаете?

1. Мьютексы (Mutexes): Мьютексы представляют собой примитивы синхронизации, позволяющие потоку получить эксклюзивный
   доступ к общему ресурсу. Мьютекс может быть захвачен только одним потоком одновременно.

2. Семафоры (Semaphores): Семафоры представляют собой примитивы синхронизации, позволяющие ограничить количество
   потоков, которым разрешен доступ к определенному ресурсу или критической секции. Семафоры могут быть использованы для
   решения проблемы ограничения ресурсов или координации потоков.

3. Условные переменные (Condition Variables): Условные переменные предоставляют механизм ожидания и оповещения потоков о
   определенных условиях. Они позволяют потокам ждать определенного состояния или события и продолжать выполнение, когда
   условие будет выполнено.

4. Счетчики (CountDownLatch): Счетчики позволяют потокам ждать завершения определенного числа операций или событий,
   прежде чем продолжить выполнение. Каждая операция или событие уменьшает значение счетчика, и потоки ждут, пока
   счетчик не станет равным нулю.

5. Барьеры (CyclicBarrier): Барьеры позволяют группе потоков синхронизироваться и ждать, пока все потоки достигнут
   определенной точки перед продолжением выполнения. Когда все потоки достигают барьера, он снимается, и все потоки
   могут продолжить выполнение.

## Что такое мьютекс? Как он работает?

Мьютекс (Mutex) - это примитив синхронизации, который обеспечивает эксклюзивный доступ к общему ресурсу. Он позволяет
только одному потоку захватить мьютекс и выполнять операции над общим ресурсом, в то время как остальные потоки ожидают
освобождения мьютекса.

Работа с мьютексом происходит следующим образом:

1. Поток пытается захватить (заблокировать) мьютекс. Если мьютекс свободен, то поток его захватывает и продолжает
   выполнение. Если мьютекс уже занят другим потоком, то текущий поток блокируется и ожидает освобождения мьютекса.
2. Поток, захвативший мьютекс, выполняет операции над общим ресурсом, обеспечивая его корректное использование.
3. После завершения работы с общим ресурсом, поток освобождает мьютекс, разблокируя его для других потоков.
4. Заблокированные потоки, ожидающие освобождения мьютекса, получают возможность продолжить выполнение и конкурентно
   пытаются захватить мьютекс.

Важно отметить, что мьютексы обычно обладают свойством владения, то есть только поток, захвативший мьютекс, может его
освободить.
Это предотвращает ситуации, когда другой поток пытается освободить мьютекс, который он не захватывал.

## Что такое семафор? Как он работает?

Семафор (Semaphore) - это примитив синхронизации, который позволяет контролировать доступ к ресурсу определенному
количеству потоков.
Семафор хранит внутреннее состояние - счетчик, который указывает на количество доступных разрешений.

Работа с семафором происходит следующим образом:

1. При инициализации семафора устанавливается начальное значение счетчика.
2. Поток, желающий получить доступ к ресурсу, пытается захватить (уменьшить) семафор. Если счетчик больше 0, то поток
   захватывает семафор и продолжает выполнение. Если счетчик равен 0, то поток блокируется и ожидает, пока другой поток
   не освободит семафор.
3. Поток, освобождающий семафор, увеличивает счетчик, позволяя другим потокам получить доступ к ресурсу.
4. Заблокированные потоки, ожидающие освобождения семафора, получают возможность продолжить выполнение и конкурентно
   пытаются захватить семафор.

Важно отметить, что семафор может быть использован для реализации не только взаимного исключения, но и для других
сценариев синхронизации, например, для управления доступом к ограниченному количеству ресурсов или синхронизации
выполнения определенных операций.

## Что такое условная переменная (conditional variable) в контексте многопоточности и зачем она используется? Какие операции можно выполнять с условными переменными?

Условная переменная (conditional variable) в контексте многопоточности - это механизм синхронизации, который позволяет
потокам ожидать определенных условий для продолжения своей работы.
Она используется для эффективной координации потоков и предоставления им возможности ждать определенных событий или
изменений состояния перед выполнением определенных действий.

Операции, которые можно выполнять с условными переменными, включают:

1. Ожидание (wait): Поток вызывает операцию ожидания на условной переменной, что приводит к его приостановке до тех пор,
   пока не будет выполнено определенное условие.
2. Уведомление (notify): Поток, работающий с условной переменной, может вызвать операцию уведомления, чтобы сообщить
   другим потокам, которые ожидают на этой переменной, о возможности продолжения работы.
3. Уведомление всех (notifyAll): Подобно операции уведомления, но сообщает всем ожидающим потокам о возможности
   продолжения работы.

## Что такое атомарные операции и как они связаны с многопоточностью? Какие примитивы синхронизации позволяют обеспечить атомарность операций?

Атомарные операции - это операции, которые выполняются как неделимые единицы, то есть они либо выполняются полностью,
либо не выполняются вообще.
В контексте многопоточности атомарность операций играет важную роль для обеспечения корректности и предсказуемости
выполнения потоков.

При выполнении параллельных операций между потоками может возникать состояние гонки (race condition), когда результат
зависит от порядка выполнения операций.
Атомарные операции позволяют избежать состояний гонки, поскольку они гарантируют, что выполнение операции не будет
прервано и не будет вмешиваться другими потоками.

Для обеспечения атомарности операций существуют примитивы синхронизации, такие как:

1. Мьютексы (Mutexes): Мьютексы обеспечивают эксклюзивный доступ к ресурсу. При использовании мьютекса только один поток
   может войти в критическую секцию, блокируя доступ для остальных потоков. Это позволяет обеспечить атомарность
   операций, которые требуют эксклюзивного доступа к общим данным.
2. Атомарные типы данных (Atomic types): Это специальные типы данных, которые обеспечивают атомарные операции чтения и
   записи. Они гарантируют, что операции над этими типами будут выполняться атомарно без необходимости использования
   блокировок или синхронизации.
3. Семафоры (Semaphores): Семафоры позволяют ограничивать доступ к ресурсу определенным количеством потоков. Они могут
   использоваться для синхронизации и координации операций между потоками, что помогает предотвратить состояния гонки и
   обеспечить атомарность определенных операций.

## Что такое паттерн "Производитель-потребитель"? Как он может быть реализован с помощью мьютексов и семафоров?

Паттерн "Производитель-потребитель" (Producer-Consumer) - это паттерн параллельного программирования, в котором задачи
разделяются на две роли: производитель, который генерирует данные, и потребитель, который потребляет данные.
Производитель и потребитель работают асинхронно, и их взаимодействие основано на общей очереди (буфере), где
производитель помещает данные, а потребитель извлекает их.

Для реализации паттерна "Производитель-потребитель" с использованием мьютексов и семафоров, мы можем использовать
следующий подход:

1. Создание общей очереди (буфера) для данных, которую производитель будет использовать для размещения данных, а
   потребитель для их извлечения. Можно использовать, например, стандартную реализацию очереди в
   Java - `java.util.concurrent.BlockingQueue`.

2. Создание семафоров и мьютексов для синхронизации доступа к общей очереди:
    - Семафор `emptySlots` указывает на количество доступных слотов в очереди, куда может быть помещен новый элемент.
      Изначально устанавливается в размер очереди.
    - Семафор `fullSlots` указывает на количество занятых слотов в очереди, которые могут быть извлечены потребителем.
      Изначально устанавливается в 0.
    - Мьютекс используется для защиты доступа к самой очереди, чтобы только один поток мог изменять ее состояние в
      конкретный момент времени. (В данном случае используется `java.util.concurrent.BlockingQueue`, поэтому мьютекс не
      нужен)

3. Реализация производителя и потребителя с использованием семафоров и мьютекса:
    - Производитель пытается захватить семафор `emptySlots`, чтобы получить разрешение на размещение элемента в очереди.
      Затем он захватывает мьютекс для доступа к очереди и помещает элемент в очередь. После размещения элемента он
      освобождает мьютекс и увеличивает семафор `fullSlots`, указывая, что в очереди доступен новый элемент для
      извлечения.
    - Потребитель пытается захватить семафор `fullSlots`, чтобы получить разрешение на извлечение элемента из очереди.
      Затем он захватывает мьютекс для доступа к очереди, извлекает элемент из очереди и освобождает мьютекс. После
      извлечения элемента он увеличивает семафор `emptySlots`, указывая, что в очереди появился свободный слот для
      размещения нового элемента.

Пример кода на Java, демонстрирующий реализацию паттерна "Производитель-потребитель" с использованием мьютексов и
семафоров:

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Producer implements Runnable {
    private BlockingQueue<Integer> buffer;
    private Semaphore emptySlots;
    private Semaphore fullSlots;
    private int value = 0;

    public Producer(BlockingQueue<Integer> buffer, Semaphore emptySlots, Semaphore fullSlots) {
        this.buffer = buffer;
        this.emptySlots = emptySlots;
        this.fullSlots = fullSlots;
    }

    public void run() {
        try {
            while (true) {
                emptySlots.acquire(); // Попытка получить разрешение на размещение элемента
                buffer.put(value); // Размещение элемента в очереди
                System.out.println("Producer produced: " + value);
                value++;
                fullSlots.release(); // Увеличение счетчика занятых слотов
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

class Consumer implements Runnable {
    private BlockingQueue<Integer> buffer;
    private Semaphore emptySlots;
    private Semaphore fullSlots;

    public Consumer(BlockingQueue<Integer> buffer, Semaphore emptySlots, Semaphore fullSlots) {
        this.buffer = buffer;
        this.emptySlots = emptySlots;
        this.fullSlots = fullSlots;
    }

    public void run() {
        try {
            while (true) {
                fullSlots.acquire(); // Попытка получить разрешение на извлечение элемента
                int value = buffer.take(); // Извлечение элемента из очереди
                System.out.println("Consumer consumed: " + value);
                emptySlots.release(); // Увеличение счетчика свободных слотов
                Thread.sleep(1000);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}

public class ProducerConsumerExample {
    public static void main(String[] args) {
        int bufferSize = 5;
        BlockingQueue<Integer> buffer = new ArrayBlockingQueue<>(bufferSize);
        Semaphore emptySlots = new Semaphore(bufferSize);
        Semaphore fullSlots = new Semaphore(0);

        Thread producerThread = new Thread(new Producer(buffer, emptySlots, fullSlots));
        Thread consumerThread = new Thread(new Consumer(buffer, emptySlots, fullSlots));

        producerThread.start();
        consumerThread.start();
    }
}
```

# 2. Многопоточность и параллелизм в Java

## Для чего нужно ключевое слово volatile?

Ключевое слово `volatile` в Java используется для обозначения переменных, которые могут быть изменены несколькими
потоками. Оно гарантирует следующее:

1. **Порядок чтения и записи**: Когда переменная объявлена как `volatile`, операции чтения и записи этой переменной
   учитываются в порядке, в котором они производятся. Это гарантирует, что изменения, внесенные одним потоком, будут
   видны другим потокам в нужном порядке.
2. **Нет кэширования**: Значение переменной `volatile` не кэшируется в локальных регистрах потока или в кэше процессора.
   Вместо этого каждое обращение к переменной `volatile` происходит напрямую из памяти, что гарантирует, что каждый
   поток видит самое актуальное значение переменной.
3. **Синхронизация без блокировок**: Ключевое слово `volatile` обеспечивает синхронизацию доступа к переменным без
   необходимости использования блокировок или других механизмов синхронизации. Это делает его полезным в случаях, когда
   потоки только читают и записывают значение переменной без выполнения других операций.

Однако важно отметить, что `volatile` не обеспечивает атомарность операций инкремента, декремента и
чтения-изменения-записи (например, `i++`). Для обеспечения атомарности таких операций необходимо использовать другие
механизмы синхронизации, например, атомарные переменные из пакета `java.util.concurrent.atomic`.

## Что такое Thread-local?

Thread-local (локальный для потока) в Java представляет собой механизм, который позволяет каждому потоку иметь свою
собственную копию переменной.
Это позволяет изолировать данные между потоками, чтобы каждый поток имел свою независимую версию переменной.

В Java реализация Thread-local осуществляется с помощью класса `ThreadLocal`.
Каждый объект `ThreadLocal` представляет собой контейнер для хранения значения, привязанного к текущему потоку. Когда
поток обращается к `ThreadLocal` для чтения или записи значения, он оперирует только своей собственной версией
переменной, которая хранится внутри этого объекта.

При использовании `ThreadLocal` в Java, каждый поток имеет доступ к своей собственной копии переменной, и изменения в
этой переменной не затрагивают другие потоки. Каждый поток воспринимает свою версию переменной как глобальную, не
замечая изменений, внесенных другими потоками.

При работе с `ThreadLocal` необходимо учитывать следующее:

- Каждый поток должен получить доступ к своей собственной версии `ThreadLocal`-переменной через вызов `get()` и `set()`.
- Переменные `ThreadLocal` обычно объявляются как статические поля класса, чтобы быть доступными из разных потоков.
- После использования `ThreadLocal` необходимо убедиться в удалении значения, чтобы избежать утечек памяти. Это можно
  сделать с помощью метода `remove()` или использования конструкции try-finally.

## Что такое монитор в Java?

В Java монитор - это встроенный механизм синхронизации, который позволяет обеспечить потокобезопасность при работе с
общими ресурсами.
Монитор представляет собой ассоциированный с каждым объектом блокировочный механизм, который гарантирует, что только
один поток может одновременно выполнять код, охраняемый этим монитором.
Он позволяет потокам взаимодействовать с объектом согласованным образом, используя методы wait(), notify() и
notifyAll().
Мониторы в Java реализованы с помощью ключевого слова synchronized, которое позволяет установить блокировку на объекте
или методе.

## В чем проблема использования synchronized в Java?

Когда метод или блок кода помечены как synchronized, только один поток может получить доступ к этому методу или блоку в
определенный момент времени.
Это может привести к замедлению работы программы, особенно если есть большое количество потоков, ожидающих доступа к
синхронизированному ресурсу.

## Что значит принцип "Happens before"?

Принцип "Happens before" (следует перед) в Java определяет отношение порядка между операциями в многопоточном окружении.
Он гарантирует, что определенные операции будут видны другим потокам в определенном порядке.

Согласно принципу "Happens before":

1. Все операции в одном потоке, которые предшествуют операции записи в переменную, будут видны в другом потоке после
   операции чтения этой переменной.
2. Операция записи в переменную, выполненная одним потоком, будет видна в другом потоке после операции чтения этой
   переменной.
3. Все операции, выполненные внутри одного потока, будут видны в этом потоке в том порядке, в котором они были
   выполнены.

Принцип "Happens before" предоставляет гарантии согласованности и предсказуемого поведения в многопоточной среде. Он
помогает избежать состояния гонки (race condition) и обеспечивает корректную синхронизацию доступа к общим данным.

Принцип "Happens before" определен в спецификации языка Java и может быть обеспечен с помощью различных механизмов
синхронизации, таких как `synchronized`, `volatile`, атомарные операции и синхронизаторы из
пакета `java.util.concurrent`.

## Для чего нужен пакет "java.util.concurrent"? Какие возможности он предоставляет?

Пакет "java.util.concurrent" в Java предназначен для поддержки разработки многопоточных приложений и предоставляет
широкий набор классов и интерфейсов для работы с параллельными задачами и синхронизацией потоков.
Он предоставляет следующие возможности:

1. **Пулы потоков (Thread Pools)**: Пакет `java.util.concurrent` предоставляет классы, такие как `ExecutorService`
   и `ThreadPoolExecutor`, для управления пулом потоков. Пулы потоков позволяют повторно использовать потоки и
   эффективно распределять задачи между ними.

2. **Атомарные переменные (Atomic Variables)**: Пакет предоставляет классы, такие как `AtomicInteger`, `AtomicLong` и
   другие, для обеспечения атомарных операций чтения и записи над переменными без необходимости использования
   блокировок. Это упрощает разработку безопасных потокобезопасных операций.

3. **Синхронизаторы (Synchronizers)**: `java.util.concurrent` содержит различные синхронизаторы, такие
   как `CountDownLatch`, `CyclicBarrier`, `Semaphore` и `Phaser`, которые позволяют потокам синхронизироваться и
   координировать свою работу, чтобы достичь определенного состояния или выполнить задачи с определенными условиями.

4. **Коллекции для многопоточной обработки (Concurrent Collections)**: Пакет включает в себя различные классы коллекций,
   такие как `ConcurrentHashMap`, `ConcurrentLinkedQueue` и другие, которые обеспечивают потокобезопасный доступ к
   коллекциям без необходимости использования дополнительных блокировок.

5. **Замки и условия (Locks and Conditions)**: Пакет предоставляет более гибкие механизмы синхронизации, такие как
   интерфейс `Lock` и его реализации (`ReentrantLock`, `StampedLock`), которые позволяют более точно контролировать
   доступ к общим ресурсам и создавать сложные сценарии синхронизации.

6. **Асинхронные операции (Asynchronous Operations)**: `java.util.concurrent` предлагает асинхронные версии некоторых
   операций, такие как `CompletableFuture` и `CompletionService`, которые позволяют выполнять операции в фоновом режиме
   и получать результаты асинхронно.

## Что такое класс Thread? Какие у него основные методы?

Класс `Thread` в Java представляет собой основной механизм для работы с потоками. Вот основная информация о
классе `Thread`:

В классе `Thread` в Java имеются следующие основные методы:

1. `start()`: Запускает выполнение потока путем вызова метода `run()`.
2. `run()`: Определяет код, который будет выполняться в потоке. Обычно переопределяется пользователем для определения
   желаемой функциональности.
3. `join()`: Блокирует вызывающий поток до тех пор, пока поток, на котором вызван `join()`, не завершит свое выполнение.
4. `sleep()`: Приостанавливает выполнение потока на указанное количество миллисекунд или наносекунд.
5. `interrupt()`: Прерывает выполнение потока, вызывая генерацию исключения `InterruptedException`.
6. `isInterrupted()`: Проверяет, был ли поток прерван.
7. `currentThread()`: Возвращает ссылку на объект `Thread`, представляющий текущий выполняющийся поток.
8. `getId()`: Возвращает уникальный идентификатор потока.
9. `getName()`: Возвращает имя потока.
10. `setName()`: Устанавливает имя потока.
11. `yield()`: Передает управление другому потоку более высокого приоритета. Однако, его использование не гарантирует
    точечную передачу управления.
12. `isAlive()`: Проверяет, выполняется ли поток.

Эти методы предоставляют функциональность для управления и контроля над потоками выполнения в Java.

## Что такое интерфейс Runnable? Как он связан с классом Thread?

Интерфейс `Runnable` в Java представляет собой функциональный интерфейс, используемый для создания потоков выполнения.

Интерфейс `Runnable` определяет единственный абстрактный метод `run()`, который должен быть реализован в классе,
реализующем этот интерфейс.
Метод `run()` содержит код, который будет выполняться в потоке.

При использовании интерфейса `Runnable`, вместо прямого расширения класса `Thread`, мы создаем экземпляр `Thread` и
передаем ему объект, реализующий `Runnable`, в качестве аргумента конструктора.

Класс `Thread` реализует интерфейс `Runnable`, поэтому можно передать экземпляр `Thread` в качестве аргумента
конструктора другого `Thread`.
Это обеспечивает гибкость в выборе, какой класс будет использоваться для выполнения кода в потоке.

При вызове метода `start()` на экземпляре `Thread`, переданном объекте `Runnable`, вызывается метод `run()` из
объекта `Runnable`.

## Что такое интерфейс Callable? Для чего он нужен и чем отличается от Runnable?

Интерфейс `Callable` в Java является частью пакета `java.util.concurrent` и представляет собой функциональный интерфейс,
используемый для выполнения задач в потоках и возврата результата.

Основные отличия между `Callable` и `Runnable`:

1. Возвращаемый результат: `Callable` может возвращать результат выполнения задачи с помощью метода `call()`, в то время
   как `Runnable` не возвращает никакого результата.
2. Обработка исключений: `Callable` может выбрасывать и обрабатывать исключения, в то время как `Runnable` не может
   выбрасывать проверяемые исключения без дополнительных манипуляций.
3. Удобство работы с результатом: `Callable` возвращает результат выполнения задачи в виде объекта `Future`, который
   позволяет проверить статус выполнения задачи и получить результат или обработать исключение после завершения.

## Что такое интерфейс Future? Для чего он нужен? Какие у него есть методы? Какие основные реализации этого интерфейса?

Интерфейс `Future` в Java является частью пакета `java.util.concurrent` и представляет собой механизм для управления
асинхронными задачами и получения их результатов.

Главная цель интерфейса `Future` - предоставить контроль над задачей, выполняющейся в потоке, и получить ее результаты в
будущем, когда они станут доступными. Он позволяет проверять статус выполнения задачи, ожидать ее завершения и получать
результат или обрабатывать исключение.

Основные методы интерфейса `Future`:

- `boolean cancel(boolean mayInterruptIfRunning)`: Отменяет выполнение задачи. Параметр `mayInterruptIfRunning`
  указывает, может ли задача быть прервана во время выполнения.
- `boolean isCancelled()`: Возвращает `true`, если задача была отменена перед завершением.
- `boolean isDone()`: Возвращает `true`, если задача выполнена, т.е. завершена или отменена.
- `V get() throws InterruptedException, ExecutionException`: Возвращает результат выполнения задачи. Если задача еще не
  завершена, текущий поток блокируется до ее завершения. Может выбрасывать исключения, связанные с прерыванием или
  ошибкой выполнения задачи.

Основные реализации интерфейса `Future`:

- `FutureTask`: Реализация интерфейса `Future`, которая может быть использована для управления выполнением задачи в
  потоке и получения ее результата.
- `CompletableFuture`: Расширенная реализация интерфейса `Future`, предоставляющая более высокоуровневые возможности для
  работы с асинхронными задачами, такими как комбинирование, композиция и обработка результатов.

## Что такое CompletableFuture? Какие возможности он предоставляет в сравнении с Future?

`CompletableFuture` - это расширенная реализация интерфейса `Future` в Java, которая предоставляет более высокоуровневые
возможности для работы с асинхронными задачами.

Основные возможности `CompletableFuture` по сравнению с `Future`:

1. Комбинирование и композиция: `CompletableFuture` позволяет комбинировать несколько асинхронных задач и определять
   зависимости между ними. Можно выполнять действия после завершения одной или нескольких задач, комбинировать
   результаты или цепочку выполнения задач.
2. Обработка исключений: `CompletableFuture` предоставляет удобные методы для обработки исключений, возникающих в
   процессе выполнения задачи. Можно определить блоки кода, которые будут выполнены в случае ошибки или исключения, и
   задать значения по умолчанию.
3. Управление ресурсами: `CompletableFuture` обладает методами для управления ресурсами, например, автоматическим
   закрытием открытых ресурсов после завершения задачи.
4. Таймауты: `CompletableFuture` позволяет установить таймаут для выполнения задачи и определить действия, которые будут
   выполнены, если задача не завершится в указанное время.
5. Асинхронное исполнение: `CompletableFuture` предоставляет методы для выполнения задачи асинхронно в указанном
   исполнителе (`Executor`). Можно контролировать, в каком потоке или пуле потоков будет выполняться задача.

Пример использования `CompletableFuture`:

```java
import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {

    public static void main(String[] args) throws Exception {
        CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
            // Асинхронное выполнение задачи
            return 42;
        });

        future.thenApply(result -> result * 2)
                .thenAccept(System.out::println)
                .join();
    }
}
```

## Перечислите методы CompletableFuture

1. `static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)`: Возвращает новый `CompletableFuture`, который
   завершается, когда все переданные `CompletableFuture` завершены.

2. `static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)`: Возвращает новый `CompletableFuture`, который
   завершается, когда любой из переданных `CompletableFuture` завершается.

3. `boolean cancel(boolean mayInterruptIfRunning)`: Попытка отменить выполнение `CompletableFuture`. Возвращает `true`,
   если удалось отменить успешно, иначе `false`.

4. `boolean complete(T value)`: Пытается установить значение для `CompletableFuture`. Возвращает `true`, если установка
   прошла успешно, иначе `false`.

5. `boolean completeExceptionally(Throwable ex)`: Пытается завершить `CompletableFuture` с исключением.
   Возвращает `true`, если завершение прошло успешно, иначе `false`.

6. `CompletableFuture<T> exceptionally(Function<Throwable, ? extends T> fn)`: Возвращает новый `CompletableFuture`,
   который завершается с результатом функции `fn`, если исходный `CompletableFuture` завершился исключением.

7. `T get() throws InterruptedException, ExecutionException`: Получает результат `CompletableFuture`. Если результат еще
   не доступен, блокирует вызывающий поток до его получения.

8. `T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException`: Получает
   результат `CompletableFuture` с ограничением времени ожидания. Если результат не доступен в течение указанного
   времени, выбрасывается исключение `TimeoutException`.

9. `boolean isCancelled()`: Проверяет, был ли `CompletableFuture` отменен.

10. `boolean isCompletedExceptionally()`: Проверяет, завершился ли `CompletableFuture` исключением.

11. `boolean isDone()`: Проверяет, завершился ли `CompletableFuture`, успешно или с исключением.

12. `<U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)`: Применяет функцию `fn` к результату
    завершенного `CompletableFuture` и возвращает новый `CompletableFuture`, завершающийся с результатом применения
    функции.

13. `CompletableFuture<Void> thenAccept(Consumer<? super T> action)`: Принимает действие `action`, которое будет
    выполнено с результатом завершенного `CompletableFuture`, и возвращает новый `CompletableFuture<Void>`.

14. `CompletableFuture<Void> thenRun(Runnable action)`: Принимает действие `action`, которое будет выполнено, когда
    завершится исходный `CompletableFuture`, и возвращает новый `CompletableFuture<Void>`.

15. `CompletableFuture<Void> thenCombine(CompletableFuture<? extends U> other, BiFunction<? super T,? super U,? extends V> fn)`:
    Комбинирует результаты двух `CompletableFuture` с помощью функции `fn` и возвращает новый `CompletableFuture<V>`.

16. `CompletableFuture<Void> thenAcceptBoth(CompletableFuture<? extends U> other, BiConsumer<? super T,? super U> action)`:
    Принимает действие `action`, которое будет выполнено с результатами двух завершенных `CompletableFuture`, и
    возвращает новый `CompletableFuture<Void>`.

17. `CompletableFuture<Void> runAfterBoth(CompletableFuture<?> other, Runnable action)`: Принимает действие `action`,
    которое будет выполнено, когда оба `CompletableFuture` завершены, и возвращает новый `CompletableFuture<Void>`.

18. `CompletableFuture<T> applyToEither(CompletableFuture<? extends T> other, Function<? super T, U> fn)`: Применяет
    функцию `fn` к результату первого завершенного `CompletableFuture` и возвращает новый `CompletableFuture`,
    завершающийся с результатом применения функции.

19. `CompletableFuture<Void> acceptEither(CompletableFuture<? extends T> other, Consumer<? super T> action)`: Принимает
    действие `action`, которое будет выполнено с результатом первого завершенного `CompletableFuture`, и возвращает
    новый `CompletableFuture<Void>`.

20. `CompletableFuture<Void> runAfterEither(CompletableFuture<?> other, Runnable action)`: Принимает действие `action`,
    которое будет выполнено, когда хотя бы один из `CompletableFuture` завершится, и возвращает
    новый `CompletableFuture<Void>`.

21. `static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)`: Асинхронно выполняет поставщик `supplier` и
    возвращает новый `CompletableFuture`, завершающийся результатом выполнения поставщика.

22. `static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)`: Асинхронно выполняет
    поставщик `supplier` с использованием заданного исполнителя `executor` и возвращает новый `CompletableFuture`,
    завершающийся результатом выполнения поставщика.

## Что такое ExecutorService? Для чего он нужен? Какие у него методы? Какие основные реализации?

`ExecutorService` в Java является интерфейсом из пакета `java.util.concurrent` и представляет собой механизм управления
исполнением задач в потоках.

Основное назначение `ExecutorService` - предоставление пула потоков для выполнения асинхронных задач. Он упрощает
управление потоками, обеспечивает повторное использование потоков и предоставляет удобные методы для отправки задач на
исполнение и получения их результатов.

Некоторые методы `ExecutorService`:

- `void execute(Runnable command)`: Помещает задачу (`Runnable`) в очередь на выполнение и запускает ее асинхронно в
  одном из потоков пула.
- `Future<?> submit(Runnable task)`: Помещает задачу (`Runnable`) в очередь на выполнение и возвращает объект `Future`,
  который позволяет проверить статус выполнения задачи и получить ее результат.
- `Future<T> submit(Callable<T> task)`: Помещает задачу (`Callable`) в очередь на выполнение и возвращает
  объект `Future`, который позволяет проверить статус выполнения задачи и получить ее результат.
- `void shutdown()`: Останавливает принятие новых задач и плавно завершает все выполнение задач, которые находятся в
  очереди.
- `List<Runnable> shutdownNow()`: Останавливает принятие новых задач и пытается прервать выполнение задач, которые
  находятся в очереди. Возвращает список задач, которые были в очереди на момент остановки.

Основные реализации `ExecutorService`:

- `ThreadPoolExecutor`: Расширенная реализация `ExecutorService`, которая предоставляет гибкую настройку пула потоков с
  учетом размера пула, ограничений на количество одновременных потоков, очереди задач и т.д.
- `ScheduledThreadPoolExecutor`: Расширение `ThreadPoolExecutor`, которое добавляет возможность планирования выполнения
  задач в определенное время или через определенные интервалы времени.
