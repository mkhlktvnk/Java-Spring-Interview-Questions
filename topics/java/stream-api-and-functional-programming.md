# Stream API

## Что такое функциональное программирование?
Функциональное программирование — парадигма программирования, в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних 
(в отличие от функций как подпрограмм в процедурном программировании).

## Что такое Stream API?
Stream API в Java представляет собой набор функциональных операций, которые могут быть применены к коллекциям объектов для обработки их элементов с использованием функционального программирования. 
Stream API предоставляет удобный и эффективный способ для работы с данными, позволяя выполнять фильтрацию, сортировку, отображение, сведение и другие операции над элементами коллекции. 
Он позволяет писать более компактный и выразительный код, а также может обеспечивать параллельную обработку данных для повышения производительности. 
Stream API предоставляет удобный способ работы с большими объемами данных и упрощает операции с коллекциями в Java.

## Что такое функциональный интерфейс?
Функциональный интерфейс в Java - это интерфейс, который содержит только один абстрактный метод. 
Он используется в функциональном программировании и поддерживает использование лямбда-выражений или ссылок на методы в качестве аргументов или возвращаемых значений. 
Функциональные интерфейсы в Java обеспечивают удобный способ определения и использования поведения в виде объектов, что делает код более читаемым и гибким. 
Примерами функциональных интерфейсов в Java являются `Runnable`, `Comparator`, `Consumer` и `Function`.

## Какие функциональные интерфейсы используются в Stream API?
1. `Predicate<T>` - предикат, принимающий объект типа T и возвращающий логическое значение (boolean). Применяется в методе `filter` для фильтрации элементов по определенному условию.

2. `Function<T, R>` - функция, принимающая объект типа T и возвращающая объект типа R. Применяется в методах `map`, `flatMap` и `collect` для преобразования элементов в другой тип или в другую структуру.

3. `Consumer<T>` - потребитель, принимающий объект типа T и выполняющий некоторые операции над ним. Применяется в методе `forEach` для выполнения операций над каждым элементом.

4. `Supplier<T>` - поставщик, не принимающий аргументов и возвращающий объект типа T. Применяется в методе `generate` для генерации элементов.

5. `Comparator<T>` - компаратор, принимающий два объекта типа T и возвращающий целое число, указывающее их отношение. Применяется в методах `sorted` и `min`/`max` для сортировки или определения наименьшего/наибольшего элемента.

6. `BiPredicate<T, U>` - бинарный предикат, принимающий два объекта типов T и U и возвращающий логическое значение (boolean). Применяется в методе `filter` для фильтрации элементов по условию, зависящему от двух параметров.

7. `BinaryOperator<T>` - бинарный оператор, принимающий два объекта типа T и возвращающий объект типа T. Применяется в методе `reduce` для комбинирования двух элементов.

## Что представляет собой Stream?
Stream в Java представляет собой последовательность элементов, через которую можно осуществлять операции для обработки и манипуляции с данными.
Он предоставляет возможность выполнения функциональных операций над элементами коллекции или других источников данных.

Stream не является структурой данных, а скорее абстракцией, которая позволяет работать с данными лениво (lazy) и потоково (streaming).
Он может быть создан из коллекций, массивов или других источников данных. 
Stream API позволяет выполнять различные операции над потоком данных, такие как фильтрация, преобразование, сортировка, агрегация и другие.

## Что такое конвейерные и терминальные методы в Stream API?
Конвейерные (Intermediate) методы и терминальные (Terminal) методы являются двумя типами операций, которые могут быть применены к потоку данных в Stream API в Java.

Конвейерные методы - это операции, которые могут быть выполнены последовательно и возвращают другой поток данных в результате. 
Они применяются для преобразования, фильтрации или сортировки элементов в потоке. Некоторые примеры конвейерных методов: `filter`, `map`, `sorted`, `distinct`. 
Эти методы не выполняют непосредственно операций над элементами, а лишь формируют цепочку преобразований.

Терминальные методы - это операции, которые завершают поток данных и возвращают результат или выполняют определенное действие. 
Они являются финальными операциями в цепочке операций и запускают выполнение всех предшествующих конвейерных методов. 
Примеры терминальных методов: `forEach`, `collect`, `count`, `min`, `max`. Терминальные методы приводят к завершению потока данных и обработке элементов.

## Перечислите конвейерные и терминальные методы Stream API

Конвейерные (Intermediate) методы в Stream API:
1. `filter(Predicate<T> predicate)` - возвращает новый поток, содержащий только элементы, удовлетворяющие заданному предикату.
2. `map(Function<T, R> mapper)` - применяет функцию к каждому элементу потока и возвращает поток, содержащий результаты преобразования.
3. `flatMap(Function<T, Stream<R>> mapper)` - преобразует каждый элемент потока в новый поток и объединяет результаты в один поток.
4. `distinct()` - возвращает новый поток, содержащий только уникальные элементы.
5. `sorted()` - возвращает новый поток с отсортированными элементами.
6. `limit(long maxSize)` - возвращает поток, содержащий не более заданного количества элементов.
7. `skip(long n)` - пропускает заданное количество элементов и возвращает оставшиеся элементы.

Терминальные (Terminal) методы в Stream API:
1. `forEach(Consumer<T> action)` - выполняет указанное действие для каждого элемента потока.
2. `toArray()` - возвращает массив, содержащий элементы потока.
3. `collect(Collector<T, A, R> collector)` - выполняет некоторую агрегацию операций над элементами и возвращает результат в заданной форме.
4. `count()` - возвращает количество элементов в потоке.
5. `min(Comparator<T> comparator)` - возвращает минимальный элемент в потоке в соответствии с заданным компаратором.
6. `max(Comparator<T> comparator)` - возвращает максимальный элемент в потоке в соответствии с заданным компаратором.
7. `anyMatch(Predicate<T> predicate)` - возвращает true, если хотя бы один элемент потока удовлетворяет заданному предикату.
8. `allMatch(Predicate<T> predicate)` - возвращает true, если все элементы потока удовлетворяют заданному предикату.
9. `noneMatch(Predicate<T> predicate)` - возвращает true, если ни один элемент потока не удовлетворяет заданному предикату.
10. `findFirst()` - возвращает первый элемент в потоке, если таковой существует.
11. `findAny()` - возвращает любой элемент в потоке, если таковой существует.

## Чем отличается `map` от `flatMap`?
- `map` преобразует каждый элемент потока независимо и возвращает поток с преобразованными элементами в том же порядке.
- `flatMap` преобразует каждый элемент потока в поток(и) и объединяет их в один поток элементов.

## Чем отличается `stream` от `parallelStream`?
- `stream` создает последовательный поток, в котором операции над элементами выполняются последовательно.
- `parallelStream` создает параллельный поток, в котором операции над элементами выполняются параллельно, если это возможно.

## Какие методы в Stream API можно использовать для агрегации элементов в коллекцию или другую структуру данных?
1. `collect()`: Этот метод позволяет собирать элементы потока в коллекцию или другую структуру данных с помощью переданного коллектора. Коллекторы предоставляют различные операции агрегации, такие как группировка, суммирование, нахождение минимального или максимального значения и другие.

2. `toList()`, `toSet()`, `toMap()`: Эти методы являются специализированными коллекторами, которые собирают элементы потока в список, множество или отображение соответственно.

3. `joining()`: Этот метод собирает элементы потока в одну строку, соединяя их с помощью указанного разделителя.

4. `groupingBy()`: Этот метод позволяет группировать элементы потока по заданному критерию и собирать их в отображение, где ключи представляют группировочные критерии, а значения - списки элементов, принадлежащих каждой группе.

5. `partitioningBy()`: Этот метод разделяет элементы потока на две группы (true и false) на основе заданного предиката и собирает их в отображение, где ключи являются результатом предиката, а значения - списки элементов, соответствующих каждой группе.

## Какие методы Stream API можно использовать для математических операций над потоком?
1. `min()`: Этот метод находит минимальное значение в потоке с использованием естественного порядка сравнения или заданного компаратора.

2. `max()`: Этот метод находит максимальное значение в потоке с использованием естественного порядка сравнения или заданного компаратора.

3. `sum()`: Этот метод вычисляет сумму всех числовых элементов в потоке. Он доступен только для числовых типов потока (int, long, double).

4. `average()`: Этот метод вычисляет среднее значение всех числовых элементов в потоке. Он доступен только для числовых типов потока (int, long, double).

5. `count()`: Этот метод подсчитывает количество элементов в потоке.

6. `reduce()`: Этот метод выполняет редукцию элементов потока с использованием указанной операции. Например, можно использовать метод `reduce()` для вычисления суммы или произведения числовых элементов.

## Какие методы в Stream API можно использовать для сортировки элементов в потоке?
1. `sorted()`: Этот метод сортирует элементы потока в естественном порядке сравнения. Если элементы потока не реализуют интерфейс `Comparable`, необходимо предоставить собственный компаратор.

2. `sorted(Comparator comparator)`: Этот метод сортирует элементы потока с использованием указанного компаратора. Компаратор задает критерий сравнения элементов.

3. `sorted(Comparator comparator, Predicate condition)`: Этот метод сортирует элементы потока, удовлетворяющие заданному условию, с использованием указанного компаратора.

4. `reverseOrder()`: Этот метод возвращает компаратор, который обратно сортирует элементы в потоке.

5. `naturalOrder()`: Этот метод возвращает компаратор, который сортирует элементы в потоке в естественном порядке.

6. `thenComparing()`: Этот метод позволяет сортировать элементы потока по нескольким критериям. Он принимает в качестве аргумента вторичный компаратор и выполняет сортировку сначала по первичному компаратору, а затем по вторичному компаратору, если элементы равны по первичному критерию.


