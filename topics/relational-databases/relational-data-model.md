# Реляционная модель данных

## Что такое база данных?

База данных - это структурированная коллекция данных, которая организована и хранится в централизованном месте. Она
предназначена для эффективного хранения, управления и извлечения информации.
Основные характеристики базы данных:

1. Централизация: База данных объединяет данные из различных источников в единую систему для удобного доступа и
   управления ими.

2. Структурированность: Данные в базе данных организованы в определенную структуру, которая определяет типы данных и их
   связи. Это позволяет эффективно хранить и обрабатывать информацию.

3. Управление: База данных обеспечивает механизмы для добавления, изменения и удаления данных, а также контроля
   целостности, безопасности и доступа к данным.

4. Поиск и извлечение: База данных позволяет осуществлять поиск и извлечение данных с использованием структурированных
   запросов, что упрощает анализ и получение нужной информации.

5. Масштабируемость: Базы данных могут масштабироваться по объему данных и количеству пользователей, обеспечивая высокую
   производительность и доступность.

6. Поддержка транзакций: Базы данных поддерживают механизмы транзакций для обеспечения целостности данных и сохранения
   их в согласованном состоянии.

7. Резервное копирование и восстановление: Базы данных предоставляют средства для резервного копирования данных и
   восстановления в случае сбоев или потери информации.

## Что такое реляционная модель данных?

Реляционная модель данных - это структурированный подход к организации и управлению данными в базе данных.

Основные характеристики реляционной модели данных:

1. Таблицы: Данные в реляционной модели организованы в виде таблиц, состоящих из строк (кортежей) и столбцов (
   атрибутов). Каждая таблица представляет отдельную сущность или тип данных.

2. Реляционные ключи: Реляционная модель использует ключи для установления связей между таблицами. Основной ключ (
   primary key) одной таблицы может быть связан с внешним ключом (foreign key) другой таблицы, что позволяет
   устанавливать связи и отношения между данными.

3. Нормализация: Реляционная модель применяет нормализацию для устранения избыточности и повышения эффективности базы
   данных. Нормализация разделяет данные на более мелкие таблицы, чтобы уменьшить повторение информации и обеспечить
   целостность данных.

4. Декларативный язык запросов: Реляционная модель поддерживает декларативный язык запросов, такой как SQL (Structured
   Query Language). С помощью SQL можно осуществлять операции выборки, вставки, обновления и удаления данных без явного
   указания способа их выполнения.

5. Гибкость и расширяемость: Реляционная модель позволяет добавлять новые таблицы, изменять структуру базы данных и
   выполнять сложные запросы с использованием соединений (joins) между таблицами.

6. ACID-свойства: Реляционная модель обеспечивает ACID-свойства для транзакций, гарантируя их атомарность,
   согласованность, изолированность и долговечность.

7. Широкое применение: Реляционная модель данных широко используется во многих областях, включая бизнес, финансы,
   здравоохранение, телекоммуникации и другие, благодаря своей гибкости, надежности и эффективности.

Реляционная модель данных была предложена Эдгаром Коддом в 1970 году и стала одним из наиболее распространенных подходов
к организации данных в базах данных.

## Что такое нормализация в реляционной модели данных? Какие выделяют нормальные формы? Опишите их

Нормализация в реляционной модели данных - это процесс организации и структурирования таблиц базы данных для устранения
избыточности данных и повышения их эффективности.
Цель нормализации состоит в достижении более гибкой и эффективной структуры базы данных, обеспечивая минимизацию
избыточности и повышение целостности данных. Каждая нормальная форма стремится к устранению определенных видов аномалий
и зависимостей в данных, что способствует более логичному и эффективному хранению и использованию информации.

Основные нормальные формы:

1. Первая нормальная форма (1NF): Гарантирует атомарность данных и требует, чтобы каждая ячейка таблицы содержала только
   одно значение.

2. Вторая нормальная форма (2NF): Устраняет избыточность данных и требует, чтобы каждый неключевой атрибут зависел
   только от полного основного ключа таблицы.

3. Третья нормальная форма (3NF): Устраняет транзитивные зависимости между неключевыми атрибутами и требует, чтобы
   каждый неключевой атрибут зависел только от основного ключа таблицы или от других неключевых атрибутов, но не от их
   комбинации.

4. Четвёртая нормальная форма (4NF): Устраняет многозначные зависимости и требует, чтобы каждый неключевой атрибут
   зависел только от основного ключа таблицы, но не от множества значений других неключевых атрибутов.

5. Пятая нормальная форма (5NF) или нормальная форма проекции (Project-Join Normal Form, PJ/NF): Устраняет зависимости
   между неключевыми атрибутами, которые могут быть следствием множественных связей и требует, чтобы каждый неключевой
   атрибут зависел только от основного ключа таблицы и не зависел от других неключевых атрибутов.

## Что такое денормализация в реляционной модели данных? Когда и для чего она применяется?

Денормализация в реляционной модели данных - это процесс объединения таблиц и добавления избыточных данных для улучшения
производительности запросов и упрощения модели данных. Она противоположна нормализации, которая стремится к минимизации
избыточности данных.

Денормализация применяется в следующих случаях:

1. Улучшение производительности запросов: При выполнении сложных запросов, которые объединяют несколько таблиц,
   денормализация позволяет избежать дорогостоящих операций объединения и ускорить выполнение запросов.

2. Упрощение модели данных: Денормализация может быть полезна, когда требуется упростить структуру базы данных, особенно
   при работе с большим объемом данных и сложными связями между таблицами.

3. Улучшение чтения данных: Если большая часть операций с базой данных связана с чтением данных, денормализация может
   увеличить производительность, так как данные становятся доступными в одной таблице без необходимости объединения.

4. Предварительное вычисление и агрегация данных: Денормализация может использоваться для предварительного вычисления и
   сохранения агрегированных данных, таких как суммы, средние значения и общие значения, что упрощает выполнение
   запросов, связанных с агрегацией.

## Что такое функциональная зависимость в реляционной модели данных? Какие виды функциональных зависимостей существуют?

Функциональная зависимость в реляционной модели данных определяет связь между атрибутами в таблице. Она указывает, что
значение одного или нескольких атрибутов определяется значением других атрибутов. Виды функциональных зависимостей,
которые существуют:

1. Полная функциональная зависимость: Значение одного атрибута полностью определяется значениями других атрибутов в
   таблице.
   Пример: В таблице "Сотрудники" атрибут "Зарплата" полностью зависит от атрибута "Должность", то есть для каждой
   должности существует однозначная зарплата.

2. Частичная функциональная зависимость: Значение одного атрибута зависит от значения других атрибутов, но не всех.
   Пример: В таблице "Сотрудники" атрибут "Отдел" частично зависит от атрибута "ID сотрудника" и атрибута "Дата приема
   на работу". Один сотрудник может принадлежать только к одному отделу на определенную дату.

3. Транзитивная функциональная зависимость: Значение одного атрибута зависит от значений других атрибутов через
   промежуточные зависимости.
   Пример: В таблице "Студенты" атрибут "Факультет" транзитивно зависит от атрибута "Группа", который в свою очередь
   зависит от атрибута "Студент". Таким образом, факультет определяется через промежуточную зависимость от студента
   через группу.

4. Многозначная зависимость: Одинаковым значениям набора атрибутов могут соответствовать различные значения других
   атрибутов.
   Пример: В таблице "Заказы" набор атрибутов "Номер заказа" и "Дата заказа" может соответствовать нескольким значениям
   атрибута "Покупатель".

## Что такое ключ в реляционной модели данных? Какие виды ключей бывают?

В реляционной модели данных ключ - это атрибут или комбинация атрибутов, который уникально идентифицирует каждую запись
в таблице. Ключи используются для установления связей между таблицами и обеспечения целостности данных.

Основные виды ключей в реляционной модели данных:

1. Первичный ключ (Primary Key): Первичный ключ однозначно идентифицирует каждую запись в таблице и обязательно должен
   быть уникальным для каждой записи. Он обычно выбирается из одного или нескольких атрибутов и может быть составным
   ключом.

2. Внешний ключ (Foreign Key): Внешний ключ устанавливает связь между двумя таблицами. Он представляет атрибут или
   комбинацию атрибутов, которые являются основными ключами в другой таблице. Внешний ключ обеспечивает целостность
   данных и позволяет связывать информацию из разных таблиц.

3. Уникальный ключ (Unique Key): Уникальный ключ гарантирует, что значения атрибута или комбинации атрибутов в таблице
   уникальны, но не обязательно являются основным ключом. Он предотвращает дублирование данных и обеспечивает
   индексирование для ускорения поиска.

4. Кандидатный ключ (Candidate Key): Кандидатный ключ - это атрибут или комбинация атрибутов, которые могут служить в
   качестве основного ключа. В таблице может быть несколько кандидатных ключей, но только один из них становится
   основным ключом.

5. Составной ключ (Composite Key): Составной ключ состоит из нескольких атрибутов, которые вместе образуют уникальный
   идентификатор записи в таблице. Он используется, когда один атрибут не может однозначно идентифицировать запись.

## Что такое индекс в реляционной модели данных? Какие виды индексов бывают? Для чего они применяются?

Индекс в реляционной модели данных - это структура данных, используемая для ускорения поиска, сортировки и фильтрации
данных в таблицах базы данных. Они создаются на основе одного или нескольких столбцов таблицы и представляют собой
отдельные структуры, содержащие отображение значений ключевых полей на физические адреса данных. Вот основные виды
индексов в реляционной модели данных:

1. Кластерный индекс (Clustered Index):
    - Хранит данные физически в определенном порядке на основе значений индексируемого столбца.
    - В таблице может быть только один кластерный индекс.
    - Обеспечивает быстрый доступ к данным при использовании индексированного столбца в условиях поиска.

2. Некластерный индекс (Non-clustered Index):
    - Хранит отдельную структуру данных, содержащую индексируемые значения и ссылки на соответствующие записи.
    - Может быть создано несколько некластерных индексов на одной таблице.
    - Улучшает производительность запросов при поиске, сортировке или фильтрации данных.

3. Уникальный индекс (Unique Index):
    - Гарантирует уникальность значений в индексируемом столбце или комбинации столбцов.
    - Обеспечивает быстрое выполнение операций поиска и предотвращает вставку дублирующихся значений.

4. Полнотекстовый индекс (Full-Text Index):
    - Предназначен для полнотекстового поиска в текстовых данных, например, в столбцах с большим объемом текста.
    - Обеспечивает эффективный поиск по ключевым словам и фразам.

5. Составной индекс (Composite Index):
    - Создается на основе комбинации нескольких столбцов.
    - Улучшает производительность запросов, которые используют условия фильтрации или сортировки по нескольким столбцам
      одновременно.

Индексы применяются для:

- Ускорения выполнения запросов, особенно при использовании условий поиска, сортировки и фильтрации.
- Увеличения эффективности операций вставки, обновления и удаления данных.
- Поддержания уникальности значений в столбцах.
- Полнотекстового поиска в текстовых данных.

Индексы в реляционной модели данных могут представлять собой следующие структуры данных:

1. B-деревья (B-trees): Широко используемая структура данных для индексов, обеспечивающая эффективное выполнение
   операций поиска, вставки и удаления. B-деревья поддерживают упорядочение значений индексируемых полей и обеспечивают
   балансировку для быстрого доступа к данным.

2. Хеш-таблицы (Hash tables): Используются для хеширования значений индексируемых полей и создания соответствия между
   хеш-значением и адресом данных. Хеш-таблицы обеспечивают быстрый доступ к данным по хеш-значению, но не поддерживают
   упорядочение.

3. Сортированные массивы (Sorted arrays): Массивы, отсортированные по значениям индексируемых полей. Индекс
   представляется в виде пары значений (ключ, адрес данных), что позволяет быстро выполнять поиск с использованием
   алгоритма двоичного поиска.

4. B+ деревья (B+ trees): Расширенная версия B-деревьев, часто используемая для создания индексов в базах данных. B+
   деревья обеспечивают более эффективное использование памяти и поддерживают быстрый поиск и диапазонные запросы.

5. Bitmap-индексы (Bitmap indexes): Структура данных, где каждый бит в индексе соответствует определенному значению
   индексируемого поля. Bitmap-индексы хорошо работают для булевых или небольших дискретных значений, но могут занимать
   большой объем памяти для широкого диапазона значений.

6. GiST (Generalized Search Tree): Обобщенное дерево поиска, используемое для создания индексов на геометрических и
   других сложных типах данных. GiST обеспечивает эффективную поддержку операций поиска, вставки и удаления на
   разнообразных типах данных.

## В чем отличие кластерных и некластерных индексов?

Отличие кластерных и некластерных индексов в реляционной модели данных заключается в следующем:

- Кластерные индексы определяют физический порядок данных на диске, а некластерные индексы - нет.
- В таблице может быть только один кластерный индекс, но несколько некластерных индексов.
- Кластерный индекс группирует данные физически на диске, в то время как некластерный индекс создает отдельную структуру
  данных для индексации.
- Использование кластерного индекса обычно приводит к улучшению производительности операций, связанных с физическим
  порядком данных, в то время как некластерные индексы улучшают производительность поиска и фильтрации данных.

## Какие существуют связи в реляционных базах данных?

В реляционных базах данных существуют следующие виды связей:

1. Один к одному (One-to-One):
    - Описание: Каждая запись в одной таблице связана с одной записью в другой таблице.
    - Пример: Связь между таблицами "Сотрудники" и "Паспортные данные". Каждый сотрудник имеет только один паспорт.

2. Один ко многим (One-to-Many):
    - Описание: Каждая запись в одной таблице связана с несколькими записями в другой таблице.
    - Пример: Связь между таблицами "Страны" и "Города". Каждая страна может иметь несколько городов.

3. Многие ко многим (Many-to-Many):
    - Описание: Множество записей в одной таблице связано с множеством записей в другой таблице.
    - Пример: Связь между таблицами "Студенты" и "Курсы". Один студент может записаться на несколько курсов, и один курс
      может быть выбран несколькими студентами. Для реализации такой связи требуется дополнительная промежуточная
      таблица "Регистрация на курсы", которая хранит связи между студентами и курсами.

## Что такое транзакция в реляционной базе данных? Что такое принципы ACID и как они связаны с транзакциями?

Транзакция в реляционной базе данных представляет собой логическую операцию или набор операций, которые выполняются как
единое целое.
Она обладает свойствами ACID (атомарность, согласованность, изолированность, долговечность), обеспечивающими надежность
и целостность данных.

Принципы ACID:

1. Атомарность (Atomicity):
    - Гарантирует, что все операции внутри транзакции либо выполняются полностью, либо не выполняются вообще. Нет
      промежуточных состояний.

2. Согласованность (Consistency):
    - Транзакция должна приводить базу данных к согласованному состоянию. После успешного выполнения транзакции должны
      быть соблюдены все правила и ограничения целостности данных.

3. Изолированность (Isolation):
    - Транзакции должны выполняться параллельно, но быть изолированными друг от друга. Операции одной транзакции не
      должны видеть промежуточные результаты другой транзакции, пока она не будет завершена.

4. Долговечность (Durability):
    - Успешно завершенные операции транзакции должны сохранять свои изменения даже в случае отказа системы или сбоя.
      Изменения должны быть долговечными и доступными после перезапуска системы.

Транзакции используются для обеспечения целостности данных и предоставления механизма отмены или коммита изменений. Они
обычно применяются в следующих ситуациях:

- Обновление нескольких таблиц или записей, где необходимо убедиться в согласованности изменений.
- Выполнение операций, требующих контроля целостности данных, например, перевод денежных средств между счетами.
- Работа с параллельными запросами, где требуется изоляция изменений для предотвращения конфликтов и гарантированного
  сохранения целостности данных.

## Что такое уровень изоляции транзакции? Какие уровни изоляции бывают и для чего применяется каждый из них?

Уровень изоляции транзакции определяет, как изменения, внесенные одной транзакцией, видны для других транзакций и каким
образом обеспечивается их изоляция друг от друга. В реляционных базах данных существуют различные уровни изоляции,
каждый из которых обладает своими особенностями. Вот описание и примеры каждого уровня:

1. Уровень изоляции READ UNCOMMITTED:
    - Этот уровень изоляции позволяет читать незафиксированные данные из других транзакций.
    - Пример использования: Одна транзакция может прочитать данные, которые другая транзакция еще не закрепила.
      Например, если две транзакции обновляют одну и ту же запись, транзакция с уровнем READ UNCOMMITTED может увидеть
      изменения другой транзакции, которые еще не были подтверждены.

2. Уровень изоляции READ COMMITTED:
    - Этот уровень изоляции гарантирует чтение только зафиксированных данных из других транзакций.
    - Пример использования: При выполнении запроса в рамках транзакции с уровнем READ COMMITTED будут видны только те
      изменения, которые были подтверждены другими транзакциями. Новые изменения, которые не были закреплены, не будут
      видны.

3. Уровень изоляции REPEATABLE READ:
    - Этот уровень изоляции гарантирует, что все данные, прочитанные в рамках транзакции, останутся постоянными до ее
      завершения.
    - Пример использования: Если транзакция выполняет несколько чтений одних и тех же данных, они будут постоянными в
      течение всей транзакции, даже если другие транзакции выполняют изменения в этих данных.

4. Уровень изоляции SERIALIZABLE:
    - Этот уровень изоляции обеспечивает наивысший уровень изоляции, гарантируя, что каждая транзакция выполняется
      последовательно, как если бы она была единственной транзакцией в системе.
    - Пример использования: Если две транзакции пытаются изменить одну и ту же запись, транзакция с уровнем SERIALIZABLE
      будет блокировать вторую транзакцию до завершения первой, чтобы предотвратить конфликты изменений.

## Какие проблемы могут возникать при параллельном доступе транзакций к одним и тем же данным?

При параллельном доступе транзакций к одним и тем же данным могут возникать следующие проблемы:

1. Потерянное обновление (Lost Update):
    - Одна транзакция перезаписывает изменения, внесенные другой транзакцией, без учета этих изменений.
    - Пример: Пусть транзакция A увеличивает значение счета на 100, а транзакция B увеличивает его на 50. Если
      транзакция B выполняется после транзакции A, но завершается раньше, то изменения транзакции A будут потеряны, и
      итоговое значение счета будет неправильным.

2. Неповторяющееся чтение (Non-repeatable Read):
    - Транзакция читает данные дважды, но получает разные значения из-за изменений, внесенных другой транзакцией между
      чтениями.
    - Пример: Транзакция A считывает значение счета и выполняет вычисления на его основе. При этом транзакция B изменяет
      значение счета. Если транзакция A повторно считывает значение счета, оно будет отличаться от предыдущего чтения, и
      результаты вычислений могут быть неправильными.

3. Фантомное чтение (Phantom Read):
    - Транзакция выполняет запрос на чтение набора записей, но получает разное количество записей из-за вставки или
      удаления другой транзакции.
    - Пример: Транзакция A выполняет запрос для получения всех клиентов с определенным фильтром. В то же время,
      транзакция B вставляет нового клиента, который соответствует фильтру транзакции A. При повторном выполнении
      запроса транзакция A обнаружит новую запись (фантом), которая не была доступна на первом чтении.

Эти проблемы могут привести к некорректным результатам и нарушению целостности данных при параллельном доступе к одним и
тем же данным. Поэтому необходимо применять соответствующие механизмы контроля параллелизма и изоляции транзакций, такие
как блокировки, уровни изоляции и оптимистическая конкурентная обработка, чтобы предотвратить эти проблемы.
